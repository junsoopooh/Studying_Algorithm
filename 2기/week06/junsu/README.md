바탕화면 정리(2번) : 처음엔 보고 조금 겁먹었지만 의외로 한번에 풀려버렸다. 존재하는 파일들을 모두 포함하는 드래그 중 가장 거리가 짧은 것을 찾기 위해 DFS나 BFS를 이용해야하나? 라는 생각을 했었다. 하지만 결국 존재하는 파일들의 x 좌표 값중 최솟값과 최댓값, y 좌표 중 최솟값과 최댓값만 찾으면 해결되는 문제였다. 조금 유의할 것은, 최댓값의 좌표에는 +1을 해주어야 한다. 파일의 좌측 상단 모서리를 기준으로하기 때문에 파일을 포함시키기 위해선 파일의 우측 하단 모서리까지 포함해야 한다.

숫자의 표현(3번) : 처음엔 DP로 생각했음. 생각하다보니, DP 라면 이전 것들이 계속 더해지는 형태라는 의미인데, 결국 숫자가 너무 커질 것이라는 생각이 들었음. 따라서, 어떤 수로 나눈 나머지를 기록하도록 문제가 나왔을거라고 생각함. 그래서 DP가 아닌 규칙성을 찾기로 함. 홀수의 경우 절반으로 나눈 몫과 그 몫의 1을 더한 경우가 항상 존재함. 예를 들어, 15일 때 절반으로 나눈 몫은 7임. 1은 더한 값 8과 함께 7+8=15 로 표현될 수 있음. 이 규칙은 모든 홀수에게 적용되지만, 모든 짝수에게는 적용될 수 없음. 연속된 두 개의 수는 하나는 홀수고 하나는 짝수기 때문에 결과가 홀수로만 나타나기 떄문임. 그래서 홀수 일 떄만 생각하면 된다고 판단하였음. 짝수일 떄는 0일 것이라고 생각했지만, 연속된 수는 1개만 있어도 되기 떄문에, 어떤 자연수든 자기 자신 1개로만 표현될 수 있다고 생각하여 짝수일 떄는 항상 1을 반환하게 만듬. 그 외의 홀수는 홀수로 나누면 된다고 생각했음.
예시에서 15는 4가지 경우가 있음. 15, 7+8, 4+5+6, 1+2+3+4+5 이 중 앞에 15와 7+8은 예외적인 경우로 따져서 규칙성에서 배제하였음. 1개로 나타내는 수는 앞서 말했듯 누구에게나 적용되는 규칙이고, 7+8은 홀수라면 무조건 적용되는 규칙이기 때문임. 즉 4+5+6과 1+2+3+4+5 가 15가 가지는 규칙인데, 총 더해지는 숫자의 갯수가 홀수개라고 생각했음. 가운데 수를 기준으로 양쪽에 하나씩, 두개씩, 세개씩 붙는 규칙이라고 파악했음. (2n+1)로 나누었을떄 나누어 떨어지면 됨. 15는 3,5로 나누어떨어지니 저 2개가 규칙이 생긴 것. 같은 논리로, 17과 19는 그 다음 홀수인 7로 나누어 떨어지지 않기 떄문에 15와 같은 갯수를 가질 것임. 반면 21은 7로 나누어 떨어지기 떄문에 한 가지 경우가 추가될 것이고, 그 이후 9로 나누어 떨어지는 수가 나타나면 또 추가될 것.
여기서 일부 예외가 발생하였는데, 짝수를 배제한 것이 잘못되었음. 예를 들어 1+2+3은 6임. 내가 세운 가설에 의하면 6은 연속된 수를 6 자기 자신을 제외하곤 없지만 실제로는 존재함. 따라서 짝수 홀수와 상관없이 (2n+1)로만 나누어지면 내가 만든 규칙에 적용될 수 있다고 생각하여 짝수, 홀수를 따지지 않았음

숫자 블록(4번) : 공약수 문제. 어떤 수가 소수가 아니라면, 두 공약수의 곱으로 이루어진다. 그리고 여러 공약수의 조합은 대칭된 모양이다. 14 = 2x7 이지만 7x2기도 하다는 뜻. 이 조건으로 해당 수의 최대공약수를 찾으면 된다. 우선 짝수의 최대공약수는 2로 나눈 몫이다. 나누는 수가 가장 작을때 몫이 가장 크기 떄문이다. 2보다 작은 수는 1 뿐인데 이떄는 공약수가 자기 자신이 되버린다. 공약수 자체는 맞지만 문제의 조건에 맞지 않는다. 한 가지 유의해야할 조건은 블록에 넣어야할 숫자의 크기가 정해져있다는 것. 만약 공약수이긴 해서 몫을 구했지만 해당 조건에 넘친다면, 그냥 넘어가지 말고 나누는 수를 넣어주면 된다. 단 이떄는 반복문을 종료해서는 안된다. 몫은 점점 작아지기 때문에 최댓값이 필요한 상황에서 더 볼 이유가 없지만 나누는 수는 점점 커지기 때문에 앞으로 더 큰 값이 발견될 수도 있기 떄문이다.
