## 2.2 알고리즘의 분석

알고리즘의 **분석**은 그 알고리즘을 실행하는 데 필요한 자원을 예측하는 것을 의미한다. 메모리, 통신 대역, 하드웨어 등

대부분은 계산 시간을 의미한다. 



이 책에서의 가정

- 알고리즘은 단일 프로세서와 랜덤 접근 기계(RAM, random-access machine) 모델로 가정 : 명령어는 동시X, 하나씩 실행

- 산술 연산, 데이터 이동연산, 제어 연산 등 : 상수 시간

- RAM 모델의 데이터형 : 정수(integer)와 부동소수(floating point)

- 각 워드 크기에 제한을 가정 : 입력 크기가 n인 입력을 다룰 때 정수는 상수 c>= 1에 대해 clg2비트로 표현된다고 가정(워드는 상수로 처리하므로 너무 크면 안된다.)



### 삽입 정렬의 분석 

#### 입력 크기

- 주어진 문제에 따라 다름. 
- 입력이 많은 문제에선 입력 항목의 개수(ex. 정렬, 이산 푸리에 변환 계산)
- 두 정수를 곱하는 문제에선 총 비트수
- 입력이 그래프일땐 노드와 간선의 개수로 2개일 수 있음

#### 수행시간

- 기본 연산 개수 또는 실행된 “단계”의 횟수를 말한다.

INSERTION-SORT(A)														cost					times

```c
for j = 2 to A.length					//c1		n
    key = A[j]							//c2		n-1
// A[j]를 정렬된 배열 A[1..j-1]에 삽입한다. //0		 n-1
    i = j-1								//c4		n-1
    while i > 0 and A[i] > key  		//c5		(t2+t3+..+tn)
        A[i+1] = A[i]					//c6		(t2-1)+...+(tn-1)
        i = i-1							//c7		(t2-1)+...+(tn-1)
    A[i+1] = key						//c8		n-1
```

알고리즘의 수행시간 : 각 명령문 수행시간의 합

n개의 원소에 대한 INSERTION-SORT의 수행시간 T(n)을 구하기 위해 비용과 횟수의 곱을 합하면 다음과 같다.
$$
T(n) = c_1n + c_2(n-1) + c_4(n-1) + c_5\displaystyle\sum_{j=2}^{n}t_j + c_6\displaystyle\sum_{j=2}^{n}(t_j-1) + c_7\displaystyle\sum_{j=2}^n(t_j-1)+c_8(n-1)
$$
크기가 정해져도 어떤 입력인가에 따라 수행시간은 변한다.



#### 예시1

Insertion-Sort(A)	

```c
for j = 2 to A.length
    key = A[j]
    // A[j]를 정렬된 배열A[1..j-1]에 삽입한다.
    i = j-1			
    while i > 0 and A[i] > key 
        A[i+1] = A[i]	
        i = i-1	
    A[i+1] = key
```

최선의 경우는 이미 정렬된 경우이다. 따라서 j=2, 3, …, n의 각 경우에 대해 i가 j-1로 초기화될 때 5행에서 A[i] <= key(이미 오름차순 정렬되있으므로 이전 인덱스이자 A[i]인 A[j-1]는 key인 A[j]보다 작거나 같다.) 

따라서 j = 2, 3, …, n에 대해
$$
t_j=1
$$
이므로 수행시간은 다음이 된다.


$$
T(n) = c_1n + c_2(n-1) + c_4(n-1) + c_5(n-1) +c_8(n-1) = (c_1+c_2+c_4+c_5+c_8)n-(c_2+c_4+c_5+c_8)
$$
이 수행시간을 명령분의 비용인 c에 의존하는 상수 a,b에 대한 an+b로 표현할 수 있다.

n에 관한 **선형 함수**가 된다.



#### 예시2

Insertion-Sort(A)	

```c
for j = 2 to A.length
    key = A[j]
    // A[j]를 정렬된 배열A[1..j-1]에 삽입한다.
    i = j-1			
    while i > 0 and A[i] > key 
        A[i+1] = A[i]	
        i = i-1	
    A[i+1] = key
```

최악의 경우는 역순으로 정렬된 경우이다. 따라서 j = 2, 3, …, n에 대해
$$
t_j = j
$$
이 된다. 다음 두 등식이 성립함을 이용하면
$$
\displaystyle\sum_{j=2}^{n}j = \frac{n(n+1)}{2} - 1
$$

$$
\displaystyle\sum_{j=2}^{n}(j-1)=\frac{n(n-1)}{2}
$$

최악의 경우 INSERTION-SORT의 수행시간은 다음이 된다.
$$
T(n) = c_1n + c_2(n-1) + c_4(n-1) + c_5(\frac{n(n+1)}{n}-1) + c_6(\frac{n(n-1)}{2}) + c_7(\frac{n(n-1)}{2})+c_8(n-1)
$$
정리하면
$$
T(n) = (\frac{c_5}2+\frac{c_6}2+\frac{c_7}2)n^2 + (c_1 + c_2 + c_4 + \frac{c_5}2-\frac{c_6}2-\frac{c_7}2+c_8)n-(c_2+c_4+c_5+c_8)
$$
결국 ""최악의 경우" 수행시간은 n에 관한 **이차식**이다.



#### 최악의 경우와 평균적인 경우의 분석

 **최악의 경우 수행시간** (크기가 n인 입력 중 가장 오래 걸리는 수행시간)에 관심을 가져야 하는 이유

-  알고리즘에서 최악의 경우 수행시간이 모든 입력의 수행시간에 대한 상한이 됨. 이 보다 더 오래 걸리지 않음을 확신할 수 있음.
-  어떤 알고리즘은 최악의 경우가 상당히 빈번히 발생할 수 있음.
- “평균적인 경우”가 최악의 경우만큼 거의 조힞 못한 상황일때가 종종 있음.

 

**평균 수행시간**이 중요한 경우도 있다.
**확률적 분석** 기법은 수행시간의 평균값을 구할 수 있다.

**랜덤화된 알고리즘**은 무엇이 "평균적인" 입력인지 불확실한 경우, 입력의 크기가 정해지면 가능한 모든 입력이 비슷한 정도로 나타난다고 가정하여 구한다. 



#### 증가 차수

**증가 비율** or **증가 차수** : 단순하게 추상화 차수가 가장 높은항만, 계수도 무시한채 비교한다. 

입력이 작은 경우에는 문제가 될 수 있다.

------



## 연습문제

### 2.2-1

$$
\frac{n^3}{1000}-100n^2-100n + 3
$$

위 함수를 Θ(세타)-표기법으로 나타내라.



답
$$
Θ(n^3)
$$


### 2.2-2

배열 A에 저장된 n개의 수를 정렬하는 알고리즘을 고려해보자. 먼저 A에서 가장 작은 원소를 찾아 A[1]과 바꾼다. 그리고 A에서 두 번째로 작은 원소를 찾아 A[2]와 바꾼다. 이 작업을 A의 n-1개 원소를 바꿀 때까지 계속한다. **선택 정렬**이라고 불리는 이 알고리즘에 대한 의사코드를 작성하라. 그리고 이 알고리즘이 어떤 루프 불변성을 유지하는지를 설명하고, n개를 바꿀 때까지 수행하지 않고 n-1개까지 바꾸면 되는 이유를 설명하라. 마지막으로, 선택 정렬의 최선의 경우와 최악의 경우 수행시간을 Θ(세타)-표기법으로 각각 나타내라.



답

SELECT_SORT

```c
for i = 1 to n-1		# 매번 가장 작은 원소를 A[i]와 바꾼다. 정렬 후에는 그 다음 원소부터 반복하기 때문에 가장 작은 원소를 찾는다.
    key = A[i]			# A[i]의 값을 저장
    tmp = A[i+1]		# A[i+1]를 탐색 중 비교를 위해 최솟값으로 저장
    min = i+1			# 최솟값의 index 저장
    j = i+1				# 탐색 index j 설정
    while j <= n		# 배열 A의 범위 내까지만 탐색한다.
    	if A[j]>=tmp	# 비교대상보다 클 경우
    		j = j + 1	# 다음 비교대상으로 이동
        else			# 비교대상보다 작을 경우
   			tmp = A[j]	# 그 값을 tmp로 저장한다.
            min = j		# 그 값의 인덱스를 저장해야 나중에 key와 바꿀 수 있다.
            j = j + 1	# 더 작은 값을 찾기 위해 반복을 진행한다.
	if key > tmp		# A[i]가 더 크면 바꾼다.
        A[i] = tmp		# 저장해둔 최솟값 tmp로 A[i]를 바꾼다.
        A[min] = key	# 최솟값이 있던 자리는 저장한 index를 이용해 바꿔준다.
```



루프 불변성 : 3가지 기준으로 루프의 불변을 증명

초기 조건(루프를 처음 실행할 때, 참이 되는 조건) : 인덱스 i+1부터 j 까지의 요소 중 min index에 최솟값을 가지고 있다.  

유지 조건(초기 이후에 임의 Loop에서도 참이 성립되는 조건) : 인덱스 i+1부터 j 까지의 요소 중 min index에 최솟값을 가지고 있다.

종결 조건(루프가 종료될 때 참이 되는 조건) : i =  n 일때 루프는 끝이나며, A는 오름차순 정렬이 끝나있다.



A[1]과 바꿀 대상은 index를 2부터 n까지,

A[2]와 바꿀 대상은 index를 3부터 n까지,

A[n-1]과 바꿀 대상은 index를 n부터 n까지, 즉 A[n]만 탐색한다.

A[n]은 탐색 대상 이없다.

따라서 1부터 n-1까지만 바꾸는 작업을 하므로 n-1번만 반복하면 된다.



times(횟수, 시간 아님)를 행별로 구한다. 1행과 6행은 루프의 검사가 실행되는 곳이므로 내부보다 1번 더 실행된다. t_i는 탐색 시간이다.

| 비용\행 | 1    | 2    | 3    | 4    | 5    | 6                | 7     | 8     | 9    | 10             | 11             | 12             | 13        | 14        | 15        |
| ------- | ---- | ---- | ---- | ---- | ---- | ---------------- | ----- | ----- | ---- | -------------- | -------------- | -------------- | --------- | --------- | --------- |
| TIMES   | n    | n-1  | n-1  | n-1  | n-1  | t_i-1(i는 1~n-1) | t_j-1 | t_j-1 | 0    | (j=2~n-1)t_j-1 | (j=2~n-1)t_j-1 | (j=2~n-1)t_j-1 | (j=2~n-1) | (j=2~n-1) | (j=2~n-1) |

| 행\횟수 | TIMES                                                        |
| ------- | ------------------------------------------------------------ |
| 1       | n  (루프의 맨 앞에서 검사하므로 바디 부분보다 1회 더 반복)   |
| 2       | n-1                                                          |
| 3       | n-1                                                          |
| 4       | n-1                                                          |
| 5       | n-1                                                          |
| 6       | t(i) i는 1부터 n-1까지 (루프의 맨 앞에서 검사하므로 바디 부분보다 1회 더 반복) |
| 7       | t(i) i는 1부터 n-1까지, 그 후 -1                             |
| 8       | t(i) i는 1부터 n-1까지, 그 후 -1                             |
| 9       | 0 (명령문 아님)                                              |
| 10      | t(i) i는 1부터 n-1까지, 그 후 -1                             |
| 11      | t(i), i는 1부터 n-1까지, 그 후 -1                            |
| 12      | t(i), i는 1부터 n-1까지, 그 후 -1                            |
| 13      | n-1 (while loop 탈출)                                        |
| 14      | n-1                                                          |
| 15      | n-1                                                          |

각 명령문의 실행에 따른 시간 "비용"은 상수로서 무시하여 계수를 1로 맞춘다. 모두 더하면 수행시간 T(n)은
$$
T(n) = n + (n-1) + (n-1) + (n-1) + (n-1)\\ + \displaystyle\sum_{i=1}^{n-1}t_i + (\displaystyle\sum_{i=1}^{n-1}t_i)-1 + (\displaystyle\sum_{i=1}^{n-1}t_i)-1+ 0\\ + (\displaystyle\sum_{i=1}^{n-1}t_i)-1 + (\displaystyle\sum_{i=1}^{n-1}t_i)-1 + (\displaystyle\sum_{i=1}^{n-1}t_i)-1\\ + (n-1) + (n-1) + (n-1)\\
\\
T(n) =  6\displaystyle\sum_{i=1}^{n-1}t_i+8n-12
$$


최선의 경우

이미 A가 원하는 조건(오름차순)으로 정렬되어 있는 상태가 최선의 경우이다. 그때 탐색시간 t_i = 1 이다.

T(n)에 대입하면
$$
T(n) = 6\displaystyle\sum_{i=1}^{n-1}t_i+8n-12 = 6(n-1) + 8n - 12\\
T(n) = 14n - 18\\
Θ(n)
$$


최악의 경우

A가 내림차순으로 정렬되어 있는 상태가 최악의 경우이다. 그때 탐색시간 t_i = i 이다.

T(n)에 대입하면
$$
T(n) = 6\displaystyle\sum_{i=1}^{n-1}t_i+8n-12 = T(n) = 6\displaystyle\sum_{i=1}^{n-1}i+8n-12\\
= 6(\frac{(n-1)n}2)+8n - 12 = 3n^2 + 5n - 12\\
Θ(n^2)
$$


### 2.2-3

선형 검색을 다시 생각해보자(연습문제 2.1-3 참고). 배열의 원소를 같은 확률로 검색한다고 가정하면 평균적으로 몇 개의 원소를 조사해야 하는가? 최악의 경우는 어떠한가? 선형 검색의 평균적인 경우와 최악의 경우 수행시간은 Θ(세타)-표기법으로 어떻게 나타내는가? 이 답을 증명하라.



답

선형 검색(Linear Search)은 원하는 값을 가진 원소를 찾을 때까지 배열의 처음부터 끝까지 차례로 순회하며 검색하는 알고리즘이다. 배열의 원소를 검색하는 확률을 t라고 가정한다. 최선의 경우는 가장 적은 갯수를 조사할 때이고 최악의 경우는 가장 많은 갯수를 조사할 때이다. 따라서 최선의 경우는 첫 검사 원소에서 발견하여 **1개**, 최악의 경우는 모든 원소를 검색하는 경우이므로 배열의 원소의 갯수인 **n**과 같다. 평균적으로 전체 원소 갯수의 절반인 **n/2**개를 검사하게 된다. Θ(세타)-표기법으로 나타내면

평균적인 경우 수행시간 : Θ(n) => n/2지만 계수는 무시한다.

최악의 경우 수행시간 : Θ(n)

즉, 평균의 경우와 최악의 경우 모두 입력 크기에 관한 선형 함수(일차식)이므로 수행시간이 일정 크기 이상의 배열을 검색할 경우 큰 차이점을 보이지 않는다.



### 2.2-4

최선의 경우에 알고리즘이 좋은 수행시간을 갖게 하려면 어떻게 바꿔야 하는가?



답

수행시간은 입력 크기가 충분히 크다면 증가 차수를 이용하여 세타 표기법으로 나타낸다. 따라서, 오직 입력 크기를 나타내는 미지수의 차수가 가장 높은 항만 유의미하다. 최선의 경우에 알고리즘이 좋은 수행시간을 가지기 위해선 평균적인 경우와 최악의 경우보다 차수가 낮아야 한다.

INSERTION-SORT															 COST				TIMES

```c
for j = 2 to A.length					//c1		n
    key = A[j]							//c2		n-1
// A[j]를 정렬된 배열 A[1..j-1]에 삽입한다. //0		 n-1
    i = j-1								//c4		n-1
    while i > 0 and A[i] > key  		//c5		(t2+t3+..+tn)
        A[i+1] = A[i]					//c6		(t2-1)+...+(tn-1)
        i = i-1							//c7		(t2-1)+...+(tn-1)
    A[i+1] = key						//c8		n-1
```

위 의사코드는 자주 보았던 삽입정렬이다. 삽입정렬에서 최선의 경우에는 입력 크기 n에 관한 선형 함수였던 반면, 최악의 경우는 2차식이였다. 다음의 수행시간 T(n)을 계산했던 결과는 아래 식과 같다.
$$
T(n) = c_1n + c_2(n-1) + c_4(n-1) + c_5\displaystyle\sum_{j=2}^{n}t_j + c_6\displaystyle\sum_{j=2}^{n}(t_j-1) + c_7\displaystyle\sum_{j=2}^n(t_j-1)+c_8(n-1)
$$
while문에 속한 5~7행에서 원소를 검색하는 확률을 뜻하는 t에 따라 수행시간의 최고차항이 달라진다. 최선의 경우 t가 상수값이였고, 최악의 경우 t는 입력크기 에 관한 미지수 n이였다. 

애초에 좋은 수행시간을 가지는 알고리즘을 논한다면 for 안의 while이 있는 이중 반복문을 이야기해야 한다. 하지만 최선의 경우가 기준이라면 입력 크기 n은 고려 대상이 아니다. 입력 형태를 논하는 "경우"에서 n은 고정값이기 때문이다. 위에서 t가 나타내는, '검색'과 같이 수행횟수가 확률적으로 정해지는 명령문이 입력크기와 무관한 상수의 값을 반복횟수로 가지도록 변경해야 한다. 혹여나 n을 포함하더라도 차수를 최대한 낮춰 평균, 최악의 경우와 차수의 차이를 보이도록 코드를 전개해야한다.

