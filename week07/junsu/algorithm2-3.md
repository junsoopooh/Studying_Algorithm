# 2.3 알고리즘의 설계

삽입 정렬 : **점진적**인 방법 사용

원소 A[j]를 정렬된 부분 배열 A[1 .. j-1]의 적절한 위치에 삽입



## 2.3.1 분할정복 접근법(Divide and Conquer)

- **재귀적** 구조 : 주어진 문제를 풀기 위해 자기 자신을 재귀적으로 여러 번 호출함으로써 밀접하게 연관된 부분 문제를 다룬다.
- 전체 문제를 원래 문제와 유사하지만 크기가 작은 몇 개의 부분 문제로 분할한다.
- 부분 문제를 재귀적으로 푼다.
- 찾은 해를 결합하여 원래 문제의 해를 만들어 낸다. 



### 분할정복의 3단계

1. **분할** : 현재의 문제를 같은 문제를 다루는 다수의 부분 문제로 분할
2. **정복** : 부분 문제를 재귀적으로 풀어서 정복. 부분 문제가 충분히 작은 크기면 직접적인 방법으로 푼다.
3. **결합** : 부분 문제의 해를 결합하여 원래 문제의 해가 되도록 만듬.



ex) **병합 정렬**(merge sort)

1.  **분할** : 정렬한 n개 원소의 배열을 n/2개씩 부분 수열 두 개로 분할한다.
2.  **정복** : 병합 정렬을 이용해 두 부분 배열을 재귀적으로 정렬한다.
3.  **결합** : 정렬된 두 개의 부분 배열을 병합해 정렬된 배열 하나로 만든다.

 

정렬할 수열의 크기가 1이 되면 재귀호출이 “바닥에 이르게” 된다.

병합 정렬 알고리즘에서 핵심 작업 : “결합”단계에서 정렬된 두 부분 수열을 병합하는 것 

병합을 위해 보조 프리시저인 MERGE(A,p,q,r)가 필요 (A : 배열, p,q,r : 인덱스(p<=q<r))



### Merge 프로시저

- 두 부분배열 A[p..q]와 A[q-1..r]이 정렬되어 있다고 가정 
- 이를 병합해서 정렬된 배열 하나를 만듬 
- 이것이 원래 부분 배열 A[p..r]을 대체.



- 수행시간 : O(n)

- n = r-p+1 = (병합할 원소들의 개수)

### 실행 과정 

목적 : 두 카드 더미를 병합해 카드의 앞면을 아래로 하는 정렬된 새로운 카드더미 생성

1.  탁자 위에 두 더미의 카드가 앞면이 위로 향하게 쌓여 있음.
2.  각 카드 더미는 정렬되어 가장 작은 카드가 위에 놓여 있음.
3.  주어진 두 카드 더미에서 각각 맨 위에 놓인 카드 비교
4.  더 작은것 빼내기(그 더미에는 새로운 카드가 맨 위에 나타남)
5.  빼낸 카드를 앞면이 아래로 되게 하여 결과 카드 더미에 추가
6.  3~5 과정을 두 카드 더미 중 하나가 빌 때까지 반복
7.  남은 카드 더미를 앞면이 아래로 되게 하여 출력 카드 더미에 통째로 합침.



### 추가된 기능 

- 기본 단계마다 카드 더미가 비었는지 조사하는 것은 비효율적이다.
- 각 카드 더미 바닥에 **sentinel**(경계) 카드 삽입
- ∞를 경계 카드의 값으로 이용
    - 경계 카드는 누구와 비교해도 남게 된다.
    - 경계 카드를 빼내는 경우는 두 카드 더미 모두 맨 위에 놓인 카드가 경계 카드 일때.
    - 각 카드 더미는 정렬되어 있어 가장 작은 카드가 맨 위에 놓여있게 되므로 각 카드 더미는 경계 카드만 남았다는 의미
    - 따라서 정렬할 카드가 없으므로 더 이상 알고리즘을 진행할 이유가 없어서 종료



### Merge(A,p,q,r)

```c
n1 = q - p + 1
n2 = r - q
배열 L[1..n1 + 1]과 R[1..n2+1]을 생성한다.
4for i = 1 to n1
	L[i] = A[p + i - 1]
for j = 1 to n2
    R[j] = A[q+j]
L[n1+ 1] = infinite
R[n2+1] = infinite
i = 1
j = 1
for k = p to r
	if L[i] <= R[j]
		A[k] = L[i]
		i = i + 1
	else 
        A[k] = R[j]
		j = j+1
```

1행 : 부분 배열 A[p..q]의 크기 n_1 계산

2행 : 부분 배열 A[q+1..r]의 크기 n_2 계산

3행 : 크기가 각각n_1 + 1과 n_2+1인 배열 L과 R 생성

4~5행 : 부분 배열 A[p..q]를 L[1..n1]로 복사  

6~7행 : 부분 배열 A[q + 1 .. r]을 R[1..n2]로 복사한다.

8~9행 : 배열 L과 R의 끝에 경계 카드를 삽입한다.

10~17행 : 루프 불변성을 유지하면서 기본 작업을 r-p+1번 수행



12~17행의 for 루프에서 각 반복이 시작될 때, 부분 배열 A[p..k-1]은 L[1..n1+1]과 R[1..n2+1]의 원소 중 가장 작은 값을 가진 k-p 개 원소를 정렬된 순서로 가진다. 또한 L[i]와 R[j]는 각 배열에서 A로 복사되지 않은 원소 중 가장 작은 값이 된다. 



#### 루프 불변성

이런 루프 불변성을 12-17행의 for 루프가 처음 반복하기 전에 만족하는지, 루프의 매 반복 시 불변식이 유지되는지, 루프가 종료될 때 타당성을 설명할 유용한 어떤 특성이 있는지 증명해야 함 

- 초기조건 : 루프의 첫 번째 반복이 시작되기 직전에는 k = p이므로 부분 배열 A[p..k-1]은 비어 있다. 이 빈 배열은 L과 R에서 가장 작은 k - p = 0개의 원소를 가지고 있고, i = j = 1이므로 L[i]와 R[j]는 각각 A로 복사되지 않은 원소 중 가장 작은 원소를 가지고 있다.
- 유지조건 : 각 반복 시 루프 불변성이 유지됨을 보이기 위해 먼저 L[i] <= R[j]의 경우 확인. L[i]는 아직 A로 복사되지 않은 가장 작은 원소. A[p..k-1]은 k-p개의 가장 작은 원소를 가지고 있음. 따라서 14행에서 L[i]를 A[k]로 복사하면 부분 배열 A[p..k]는 k-p+1개의 가장 작은 원소를 정렬된 순서로 저장. k(for 루프의 갱신에서)와 i(15행에서)를 증가시키는 것은 다음 반복에서의 루프 불변성 확립. L[i] > R[j]라면 비슷하게 16~17행에서 루프 불변성을 유지하기 위한 적절한 작업.  
- 종료조건 : 종료될 때 k = r + 1이다. 루프 불변성에 의해 부분 배열 A[p..k-1],  즉 A[p..r]은 L[1..n1 + 1]과 R[1..n2 +1]에서 가장 작은 k-p = r-p+1개의 원소를 정렬된 순서로 저장. 배열 L과 R은 모두 합쳐 n1 + n2 + 2 = r-p+3개의 원소를 가짐. 가장 큰 두 개의 원소(경계 카드)를 제외하고 모두 A로 복사. 



MERGE 프로시저 는 = r-p+1 일때 O(n)시간에 수행 : 1~3행과 8~11행에서 상수 시간, 4~7행의 for 루프에서 O(n1+n2) = O(n)시간, 12~17행의 for 루프에서 n번 반복 발생하고 각 루프에 상수 시간 이다.



### 정렬 알고리즘의 서브 루틴으로 MERGE 프로시저 이용 

MERGE-SORT(A,p,r) : 부분 배열 A[p..r]을 정렬하는 프로시저.

if p>=r : 부분 배열이 많아야 한개의 원소 => 이미 정렬

else : 분할 단계에서 A[p..r]을 원소가 [n/2]개인 A[p..q]와 [n/2]개인 A[q+1..r]로 분할하기 위해 인덱스 q를 계산

```c
MERGE-SORT(A,p,r)
	if p<r
		q = [(p+r)/2]
		MERGE-SORT(A,p,q,)
		MERGE-SORT(A,q+1,r)
		MERGE(A,p,q,r)
```



전체 수열 A = <A[1], A[2], ... , A[n]>을 정렬하려면 MERGE-SORT(A,1,A.length)를 호출. A.length = n



## 2.3.2 분할정복 알고리즘의 분석

알고리즘이 자기 자신을 호출하는 재귀 호출을 할 경우 수행시간 : **재귀 방정식** or **점화식**으로 설명

입력의 크기가 n인 문제에 대한 전체 수행시간을 더 작은 크기의 입력에 대한 수행시간으로 나타내는 것.



분할정복 알고리즘의 수행시간에 관한 점화식.

가정 : T(n)은 입력 크기가 n인 문제에 대한 수행시간

- 문제의 크기가 충분히 작아 상수 c에 대해 n<=c 이면 O(1)
- 주어진 문제가 원래 문제의 1/b인 a개의 부분 문제로 분할 => 크기가 n/b인 부분 문제에 T(n/b) 시간이 걸렸다면 a개 문제 해결에는 aT(n/b) 걸림.
- 문제 분할 시간 D(n)이고 부분 문제들의 해를 결합하여 원래 문제의 해 만드는데 C(n) 걸린다면 점화식은 다음과 같음

if n <= c,
$$
T(n) = O(1)
$$
otherwise,
$$
T(n) = aT(n/b) + D(n) + C(n)
$$



### 병합 정렬의 분석

n개의 수를 정렬하는 병합 정렬에서 최악의 경우 수행시간 T(n)에 관한 점화식

- n = 1, 상수 시간

- n>1 일때

    - 분할 : 분할 단계는 부분 배열의 중간 위치를 계산. 그러므로 상수시간. D(n) = O(1)

    - 정복 : 두 개의 부분 문제를 재귀적으로 푼다. 각 크기는 n/2이므로 2T(n/2)
    - 결합 : n개 원소에 대해 MERGE 프로시저는 O(n)시간. C(n) = O(n)



따라서 점화식은 다음과 같다.

if n=1,
$$
T(n) = O(1)
$$
if n >1,
$$
T(n) = 2T(n/2) + O(n)
$$

#### 4장의 "마스터 정리" 이용

T(n)은 O(n lg n), lg n 은 log(2)n -> 밑이 2인 로그

로그함수는 선형 함수보다 훨씬 천천히 증가 => 충분히 큰 입력에 대해 병합 정렬이 O(n^2)인 삽입 정렬보다 성능좋음



#### 마스터 정리 이용 X

위 점화식은 n>1 일경우 
$$
T(n) = 2T(n/2) + O(n)
$$

#### 

O(n)을 상수 c를 계수로 하는 cn 이라고 가정. 

c는 크기가 1인 문제를 푸는데 걸리는시간, 배열의 원소 갯수 당 분할과 결합 단계에서 걸리는 시간도 포함.

그렇다면 n이 1일때, T(n) = c = cn 이다.

n이 1보다 클 경우, 다음과 같은 과정을 거친다.
$$
T(n) = 2T(\frac{n}{2})+cn\\
T(\frac{n}{2}) = 2T(\frac{n}{4})+c(\frac{n}{2})\\
T(n)=2(2T(\frac{n}{4})+c\frac{n}{2})+cn = 4T(\frac{n}{4})+(\frac{cn}{2}+\frac{cn}{2})+cn\\
T(\frac{n}{4}) = 2T(\frac{n}{8})+c(\frac{n}{4})\\
T(n) = 2T(\frac{n}{2}) + cn = 4T(\frac{n}{4})+(\frac{cn}{2}+\frac{cn}{2})+cn = 8T(\frac{n}{8})+(\frac{cn}{4}+\frac{cn}{4}+\frac{cn}{4}+\frac{cn}{4}) + (\frac{cn}{2}+\frac{cn}{2}) + cn
$$


동일한 분모를 가진 nc의 합을 이루는 소괄호는 각각 총합이 cn임을 귀납적으로 알 수 있다.

재귀는 T의 인자가 1이 될때 까지 반복된다. n = 8 이라면, n = 8 = 2^3이기에 3번 반복된다. n = 2^k 라면, k번 반복된다.

각 T(x) 의 합은 결국 cn을 의미한다. 다시 말해, 재귀의 깊이는 cn을 몇번 더하는 가와 같은 뜻이다.

n의 밑을 2로 하는 로그의 값을 x로 설정한다면 lg n = x 이다. 재귀는 x번 반복하므로 총 비용은
$$
cn *x+cn = cn(log_2n)+cn = cn(log_2n+1) 
$$


낮은 차수항과 상수를 제외하고 나면 nlg(n)임을 알 수 있다.



------



## 연습문제

### 2.3-1

그림 2.4를 모델로 하여 배열 A = <3, 41, 52, 26, 38, 57, 9, 49>가 주어졌을 때 병합 정렬의 동작을 설명하라.

그림 2.4

![24](C:\coding\blog\junsoopooh.github.io\img\24-1684423356532-5.jpg)



답 : 

1. 두개씩 짝을 지어 비교하여 둘 중 작은 값을 골라 새로 만들어질 수열에 삽입한다. 
2. 남은 하나도 이후에 삽입한다. 
3. 그 결과 원소가 두개인 수열 4개 [3,41], [26,52], [38,57], [9,49] 가 생성된다. 
4. 또 두개 씩 짝을 지어 비교한다. 
5. 둘 중 작은 값을 뽑아 새로운 수열에 삽입 한다. 
6. [3,26,41,52] 와 [9,38,49,57]이 완성된다. 
7. 이 두 수열도 가장 앞의 값을 비교하며 둘 중 작은 것을 꺼내 새로운 수열에 삽입한다. 
8. 이를 반복하면 정렬된 수열 [3,9,26,38,41,49,52,57]이 결과이다.





### 2.3-2

MERGE 프로시저를, 경계값을 사용하지 않고 배열 L 또는 R이 자신의 원소를 A로 모두 복사하면 비교 작업을 끝내고 나머지 배열에서 복사되지 않고 남은 원소를 A에 모두 복사하도록 재작성하라.

답 :

MERGE(A, p, q, r)

```
n1 = q - p + 1
n2 = r - q
/* 배열 L[1 .. n1]과 R[1 .. n2]을 생성한다. */
/* 기존 n1+1, n2+1이 sentinel이였으니 생성하지 않는다. */
for i = 1 to n1
    L[i] = A[p+i-1]
for j = 1 to n2
    R[j] = A[q+j]
i = 1
j = 1
/* j, i 가 L,R의 인덱스 범위를 넘어서면 비교하지 않는다. */
/* or를 비교연산자로 설정하고 i,j 값 확인을 먼저해서 수열 길이 이상이면 */
/* 아직 남은 루프변성의 루프만 반복된다. */ 
for k = p to r 
	if j == n2+1 or L[i] ≤ R[j] 
		A[k] = L[i]
		i = i + 1
	elif i == n1+1 or L[i] > R[i] 
		A[k] = R[j]
		j = j + 1
    
```





### 2.3-3

n이 2의 거듭제곱일 때 수학적 귀납법을 이용해 다음 점화식의 해가 T(n) = nlg(n)임을 보여라

$$
T(n) = 2\ \ \ \ \ \ \ \ if\ \ n = 2  \\
T(n) = 2T(n/2)+n \ \ \ \ \ \ \ \ if\ \ n = 2^k\ \ ,for\ \ k >1
$$


답 :


$$
T(n) = 2T(\frac{n}{2}) + n \\
= 2(2T(\frac{n}{4})+\frac{n}{2})+n = 4T(\frac{n}{4})+2(\frac{n}{2}) +1(\frac{n}{1})\\
= 4(2T(\frac{n}{8})+\frac{n}{4}) + 2(\frac{n}{2}) + n = 8T(\frac{n}{8})+4(\frac{n}{4})+2(\frac{n}{2})+1(\frac{n}{1}) \\
... \\
= 2^kT(2)+2^{k-1}(\frac{n}{2^{k-1}})+2^{k-2}(\frac{n}{2^{k-2}})+ ...+2^0(\frac{n}{2^0}) \\
= 2^{k+1} + k*n \\
T(n)= 2^{k+1} + kn \\
= 2n + kn = n(k+2) \\
n = 2^k, k = log_2n \\
T(n) = n(log_2n + 2) \\
최고차항만 \ \ 남기면\\
T(n) = nlog_2n
$$






### 2.3-4

삽입 정렬은 다음과 같이 재귀 호출의 형태로 표현할 수 있다. A[1..n]을 정렬하기 위해 A[1..n-1]을 재귀적으로 정렬하고 A[n]을 정렬된 배열 A[1..n-1]에 삽입한다. 이와 같은 재귀 형태의 삽입 정렬에서 최악의 경우 수행시간에 관한 점화식을 써라



답 :

우선 삽입정렬의 동작은 다음과 같다.

1. 기존의 수열 X에서 원소 하나를 꺼낸다.
2. 정렬을 위한 수열 A에서 가장 뒤쪽부터 비교하여 새로 들어오는 값이 더 작을 때 삽입할 위치를 1칸 씩 앞으로 당긴다.
3. 새로 들어올 수가 비교 대상보다 작을 경우 진행을 멈추고 그 위치에 삽입한다.
4. 위 과정을 반복한다.

과정 1~3이 재귀적으로 반복된다. 분할정복 알고리즘에서 수행시간은 입력 크기가 n인 문제에 대한 수행시간을 T(n)이라 한다면, 원래 문제를 b로 나누어 a개의 부분문제로 만들었다. 또한 분할 시간 D(n), 부분 문제의 해 결합 시간 C(n)도 고려했다. 따라서 

T(n) = aT(n/b) + D(n) + C(n) 라고 공부하였다.

크기가 n인 수열을 삽입정렬 하는 것은 크기가 n-1일 때 삽입정렬하고 새로운 원소 A[n]을 삽입하는 것과 같다.

다음을 재귀로 반복하면 결과를 얻을 수 있다. 수행시간을 구해보면

T(n) = T(n-1) + n-1 이다.

n-1개의 크기를 삽입정렬 하고 최악의 경우이므로 A[n]을 처음부터 끝까지, 총 n-1번 비교해야 한다.
$$
T(n) = T(n-1) + (n-1) \\
= (T(n-2)+(n-2))+n-1 = T(n-2)+(n-2)+(n-1) \\
= T(n-3)+(n-3)+(n-2)+(n-1) \\
... \\
= T(1) + 1 + 2+ ... +n-1 \\
T(n) = 1 + \frac{n(n-1)}{2}
$$
최고차항만 남기면 최악의 경우 수행시간 T(n)은 T(n) = O(n^2)이다.

이전에 배운대로 수행시간이 n에 관한 이차식임을 알 수 있다.





### 2.3-5

검색 문제를 다시 살펴보자(연습문제 2.1-3 참고). 수열 A가 정렬되어 있으면 수열의 중간값과 찾고자 하는 원소 v를 비교할 수 있어 수열의 절반을 더는 비교할 필요가 없다. **이진 검색** 알고리즘은 이런 과정을 반복하는 검색 알고리즘으로, 매번 남아 있는 수열을 이등분하여 검색한다. 반복적인 방법이나 재귀적인 방법을 이용해 이진 검색에 대한 의사코드를 작성하라. 그리고 이진 검색의 최악의 경우 수행시간이 O(lgn)임을 증명하라.



답 : 

BINARY-SEARCH

```c
n = A.length 				# A의 길이
left = 1					# 왼쪽 경계 설정
right = n					# 오른쪽 경계 설정
while right >= left			# 반복문 탈출 조건 설정(충족되면 검색 실패를 의미)
	c = (left+right)/2		# 중간 index 설정
	key = A[c]				# 중간값 
    if v == k				# 찾았다면?
        return True			# 함수 종료
	if v > key				# 찾고자 하는 v가 중간값보다 크다면?
        left = c			# 정렬되어있으므로 중간값보다 작은 값들은 볼 필요 없어서 왼쪽 경계 재설정
    else v < key			# v가 작다면?
    	right = c			# v보다 큰 값들은 비교할 필요 없으므로 오른쪽 경계 재설정
```

이 과정을 중간값 key = v 가 될때까지 반복한다. 반복될수록 왼쪽이나 오른쪽 절반을 검색 범위에서 제외하므로 검색 크기는 절반씩 줄어든다. 따라서 T(n) = aT(n/b) + D(n) + C(n)은 다음과 같다.
$$
T(n) = T(\frac{n}{2}) + D(n)
$$
절반을 택하기 위한 수행시간 D(n)은 상수 값이다. 편의상 d라고 한다.

또 2를 밑으로하는 로그에 n을 대입하면 lg(n) = k라고 가정한다. 즉, 2^k = n 이므로
$$
T(n) = T(\frac{n}{2})+d \\
=T(\frac{n}{4})+d+d \\
... \\
T(n) = T(\frac{n}{2^k}) + d + ... + d
$$
T(1) = O(1)이고, d는 총 k번 더해졌다. 따라서
$$
T(n) = O(1) + kd = O(1) + d(log_2n)  \\
T(n) = log_2n
$$
상수와 계수가 1인 최고차항만 남기면 T(n)은 n의 2가 밑인 로그값임을 알 수 있다.





### 2.3-6

2.1절의 INSERTION-SORT 프로시저에서 5-7행의 while 루프가 정렬된 부분 배열 A[1 .. j-1]을 원소 하나씩 역방향으로 훑어보기 위해 선형 검색을 한다는 것을 알 수 있다. 선형 검색 대신 이진 검색(연습문제 2.3-5 참고)을 한다면 삽입 정렬의 최악의 경우 수행시간을 O(nlgn)으로 개선할 수 있을까?



답 : 

2.2절에서 삽입 정렬의 수행시간을 각 명령문 수행횟수의 합을 이용해 구하였다. 

INSERTION-SORT(A)														cost					times

```c
for j = 2 to A.length					//c1		n
    key = A[j]							//c2		n-1
// A[j]를 정렬된 배열 A[1..j-1]에 삽입한다. //0		 n-1
    i = j-1								//c4		n-1
    while i > 0 and A[i] > key  		//c5		(t2+t3+..+tn)
        A[i+1] = A[i]					//c6		(t2-1)+...+(tn-1)
        i = i-1							//c7		(t2-1)+...+(tn-1)
    A[i+1] = key						//c8		n-1
```

위를 정리하면 다음과 같았다.
$$
T(n) = c_1n + c_2(n-1) + c_4(n-1) + c_5\displaystyle\sum_{j=2}^{n}t_j + c_6\displaystyle\sum_{j=2}^{n}(t_j-1) + c_7\displaystyle\sum_{j=2}^n(t_j-1)+c_8(n-1)
$$
선형 검색일 때 최악의 경우 t = j였다. 

이진 검색일때는 최악의 경우 2.3-5를 통해 구했듯, 2를 밑으로 하는 로그를 써서  lg(j) 이다.

기존 삽입 정렬에서 수행시간에 영향을 끼치는 곳은 while문 즉, 선형 검색 부분이였다. 

n에 대한 1차식을 n번 수행하여 n에 관한 2차식으로 수행시간이 나타났다. 

lg(n)을 n번 수행한다면 nlg(n)이 된다.

추가적으로 고려해야 한다면 기존에 탐색을 하면서 while문 내에서 한번 비교할 때 마다 한 개의 원소를 한칸씩 옆으로 이동시켰다. 이진 탐색의 경우 삽입할 곳을 찾은 후 그곳까지 일괄적으로 옮겨줘야 하는데 그 부분에서 차이가 발생할까? 코드를 쓰다보니 또 내부에 반복문을 써야 할것 같아 든 생각이였다. 
x개를 이동시켰다면 선형 검색에서는 x번의 비교, x번의 이동이였다. 
이진 탐색의 경우는 더 적은 횟수로 삽입 위치를 파악한다.
하지만 삽입하기 위해서 수행시간은 결국 동일하다.
최악의 경우 처음에 주어진 수열이 내림차순 정렬일 경우이다. 따라서 새롭게 삽입하는 원소는 모두 새로운 수열의 가장 앞에 위치하기 때문이다.

따라서 이진검색으로 바꾸어도 최악의 경우 수행시간은 개선되지 않는다.





### 2.3-7

n개 정수의 집합 S와 정수 x가 주어졌을 때, S에 있는 두 원소의 합이 x가 되는 경우가 있는지를 알아내는 O(nlgn)시간 알고리즘을 작성하라.



답 : 

현재까지 배운 탐색중 이진 탐색을 사용하는게 가장 빠르다고 생각했다. 따라서 p라는 원소 하나를 추출하고, n-1개의 정수의 집합 A에서 x-p를 검색하였다.

```c
for i = 1 to n    
    p = S[i]
	target  = x - p
	left = 1					
	right = n					
	while right >= left			
	c = (left+right)/2		
	key = A[c]
    if target = key
        return true
	if target > key				
        left = c			
    else x < target			
    	right = c	
```

다음과 같이 작성하였다.

1행 for문을 통해 추출하는 원소를 바꿔주고 

6행에서 이진검색을 통해 탐색했다.

1행의 for loop의 수행시간은  n, 내부의 6번 while loop는 lgn이므로 

O(nlg(n)) 이다.
