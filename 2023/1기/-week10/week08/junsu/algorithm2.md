# 종합문제

## 2-1 병합 정렬에서 작은 배열에 대한 삽입 정렬의 적용

 병합 정렬은 최악의 경우 Θ(NlgN) 시간이 걸리고 삽입 정렬은 Θ(N^2) 시간이 걸리지만, n이 작으면 상수 인자로 인해 삽입 정렬이 많은 기계에서 더 빠르다. 그러므로 문제 크기가 충분히 작을 때는 삽입 정렬을 적용하는 것이 유용할 수 있다. 즉, 병합 정렬에서 문제 크기가 충분히 작아졌을 때는 재귀 호출의 단위를 "덩어리로 만들어" 삽입 정렬을 적용하는 것이 유용할 수 있다. 이제 변형된 병합 정렬을 고려해 보는데, 어떤 정수 k를 정한 뒤 문제를 분할하다가 크기가 k인 n/k개의 부분 리스트가 되면 삽입 정렬을 이용해 정렬하고, 이를 다시 합치는 것은 일반적인 병합 정렬의 구조를 따르도록 한다.

### a. 크기가 각각 k인 n/k개의 부분                                                                                                                                                                                                                                                                                                                      리스트를 삽입 정렬을 이용해 최악의 경우 Θ(nk)시간에 정렬할 수 있음을 보여라.

답 : 삽입정렬 최악의 경우 수행 시간은 입력 크기의 제곱이므로 크기가 k인 리스트의 삽입 정렬 수행 시간은 k의 제곱이다. 이 과정을 n/k번 반복하므로 곱해준다.
$$
k^2*\frac{n}{k}=nk
$$




### b. 이 부분 리스트를 최악의 경우 Θ(Nlg(N/k)) 시간에 병합할 수 있음을 보여라.

답 : 삽입 정렬이 끝난 후 크기가 k인 n/k개의 부분 리스트가 존재한다. 이 부분리스트를 두개씩 짝지어 병합하면 크기가 2k인 부분 리스트가 n/2k개가 존재하게 된다. 이 과정이 반복되면서 크기는 2배씩 늘어나고, 갯수는 1/2로 감소하는데, 결국 1개가 남을 때까지 계속된다. n/k 가 2의 x제곱이라면, x번 반복된다. 각 과정의 수행 시간은 n이다. 크기가 k인 리스트 2개를 병합하는 MERGE 프로시저는 수행시간이 2k이기 때문이다. 따라서 최악의 경우 병합하는 수행시간은 Nlg(N/k)이다.
$$
S = (k+k)*\frac{n}k+(2k+2k)*\frac{n}{4k}+...+(2^{x-1}k+2^{x-1}k)*\frac{n}{2^xk}\\
\frac{n}k=2^x, x = log_2{\frac{n}k} \\
S = n*log_2{\frac{n}k}=nlog_2{\frac{n}k}
$$




### c. 위 (a),(b)를 통해 최악의 경우 Θ(Nk + Nlg(N/k))시간에 실행될 수 있도록 변형된 알고리즘이 주어졌을 때, 그 알고리즘이 표준적인 병합 정렬 알고리즘과 동일한 점근적 수행시간을 갖는 k의 점근적(Θ-표기법 내의) 최댓값을 N의 함수로 표현하라.                                                                                                                                                                                                                                                                                                                                                                                                                              

Given that the modified algorithm runs in Θ(nk + nlg(n/k))  worst-case time, what is the largest value of k as a function of n for which the modified algorithm has the same running time as standard merge sort, in terms of Θ-notation?

답 : 표준적인 병합 정렬 알고리즘에서 최악의 경우 수행시간은 Θ(NlgN)이다. Θ(Nk + Nlg(N/k))에서
$$
nk+nlog_2\frac{n}k= nk+nlog_2n-nlog_2k \\
$$
k를 n과 관련된 함수라고 할때, k가 lg(n)보다 크게 증가하게 되면, 최고차항이 nlg(n)이 아니게 된다. Θ-표기법 에서는 최고차항의 차수만 고려하기 때문이다. 따라서 k의 최댓값은
$$
k=log_2n
$$
이다.



### d. 실용적으로는 k를 어떻게 정해야 하는가?

답 : 변형된 알고리즘은 입력 크기가 작아서 병합 정렬보다 삽입 정렬이 더 효율적일 때를 고려한 것이다. 그렇다면 기존에는 고려하지 않았던 n의 계수인 상수도 고려해야 할것이다. 최악의 경우 삽입 정렬의 시간 복잡도에서 계수를 c1이라 하고, 병합 정렬의 시간 복잡도 계수를 c2라고 우선 가정한다. 그 후 둘의 시간복잡도가 교차되어 병합 정렬의 시간복잡도가 더 클 때가 언제인지를 계산한다.
$$
c_1k^2 ≤ c_2klog_2k \\
\frac{k}{log_2k}≤\frac{c_2}{c_1} \\
c_1k ≤ c_2log_2k
$$
각 계수를 고려하여 위가 성립하는 k의 최댓값을 구해야 한다.







## 2-2 버블 정렬의 타당성

버블 정렬은 비효율적이지만 인기 있는 정렬 알고리즘이다. 이는 정렬되지 않은 이웃 원소를 반복적으로 바꿔 수열을 정렬한다.

BUBBLESORT(A)

```c
for i = 1 to A.length-1
    for j = A.length downto i+1
        if A[j]<A[j-1]
            A[j]와 A[j-1]을 바꾼다.
```

### a. A`을 BUBBLESORT(A)의 결과라고 하자. BUBBLESORT가 타당한지 증명하기 위해 이것이 종료하는지와 n = A.length일 때 다음이 성립하는지를 보여야 한다. BUBBLESORT가 정말 정렬할 수 있는지 보이려면 무엇을 더 증명해야 하는가?

$$
A`[1]≤A`[2]≤...≤A`[n] \ \ \ \ \ \ \ \ \ \ \ \ \ \ 부등식 \ \ (2.3)
$$

답: A`가 A의 원소들로 이루어져 정렬된 결과임을 증명해야 한다.







다음 두가지는 부등식 (2.3)을 증명한다.

### b. 2-4행의 for 루프에 대한 루프 불변성을 자세히 서술하고, 그것이 만족되는지를 증명하라. 증명 과정은 이 장에서 보인 루프 불변성 증명 구조를 잘 따라야 한다.

답 : 

루프 불변성 : 각 step에서 sentence가 같을 필요는 없다. 

n = A.length 일 때, 부분배열 A[j,j+1,..,n]는 A의 원소로 이루어져 있고 A[j]는 그  최솟값이다.

초기 조건 : 루프의 첫 반복이 시작되기 전, 즉 j = A.length일 때 부분배열 A는 A[n] 한 개의 원소로 구성되어 있다. 또한 유일한 원소이므로 최솟값이기도 하다.

유지 조건 :  A[j]는 바로 옆의 A[j-1]과 비교하는 과정을 통해 한 칸씩 옮길 수 있고 마지막이 A[i+1]이다. 따라서 A의 원소로 이루어진 부분배열에서 최솟값은 여전히 A[i+1]이자 A[j]이다.

종료 조건 : j가 A.length에서 1씩 감소하다가 i+1을 지나 j=i가 되는 순간 종료된다. 이때 부분배열은 A의 원소들로 이루어져있고 여전히 A[i]는 최솟값이다. 

루프 불변성이 만족된다.



### c. (b)에서 증명한 루프 불변성의 종료조건을 활용해 부등식 (2.3)을 자연스럽게 증명할 1-4행의 for 루프의 불변식을 보여라. 증명 과정은 이 장에서 보인 루프 불변성 증명 구조를 잘 따라야 한다.

답

루프 불변성 : A`[1,2,...,i-1] 는 A의 원소로 이루어져있고 정렬되어 있다. 

초기 조건 : i = 1일때 A`는 빈 리스트이므로 참

유지 조건 : b번 문제에서 j = i가 되면 2-4행 for 루프는 종료되었다. A[i,...,n] 부분배열에서 가장 작은 값은 앞에 있게 되고 i는 1이 증가하게 된다. 따라서 부분배열 A`에서 새로운 원소가 추가되었고 현재 가장 큰 원소이기에 가장 끝에 삽입된다. 부분배열이 정렬이 유지되므로 참

종료 조건 : i가 length가 되면 종료한다. 그렇게 되면 A의 모든 원소가 A`에 정렬된 채로 오게 된다.





### d. 버블 정렬의 최악의 경우 수행시간은 무엇인가? 그리고 삽입 정렬과 비교하면 어떠한가?

 답

최악의 경우라면 내림차순으로 정렬된 입력크기를 생각해야 한다. n = A.length이라고 가정 하면,첫번째 for loop는 n-1번 반복한다. 두번째 for loop는 그 내에서 각 n부터 i+1이 될때까지 n-(i+1)번 반복한다. 따라서 n에 관한 2차식이 성립하여 Θ(n^2)가 된다. 삽입 정렬과 동일하다.





## 2-3 Horner 공식의 타당성

다항식 계산을 위한 다음과 같은 Horner 공식이 있다.
$$
P(x) = \displaystyle\sum_{k=0}^{n}a_kx^k\\
=a_0+x(a_1+x(a_2+...+x)a+{n-1}+xa_n)...))
$$
다음 코드는 계수 a0,a1,...,an과 x값이 주어졌을 때 Horner 공식을 구현한 것이다.

```
y = 0
for i = n downto 0
	y = ai + xy
```

### a. Horner 공식을 구현한 이 코드의 점근적 수행시간을 Θ-표기법으로 나타내라.

답 : Θ(n). n부터 0까지 n+1번 반복한다.





### b. 다항식의 각 항을 처음부터 일일이 계산하는 단순한 다항식 계산 알고리즘의 의사코드를 작성하라. 이 알고리즘의 수행시간은 무엇인가, Horner 공식과 비교하면 어떠한가?

답

다항식 의 각 항을 원소로 하는 배열 A를 가정하자. 
$$
A[0] = a_0,A[1]=a_1,...,A[n]=a_n이다. \\
$$

```
ans = 0
for i = 0 to n
	tmp = A[i]
	for j = 0 to i #i번 반복해서 x^i 붙여준다.
		tmp *= x
	ans += tmp
```

2중 loop 이므로 Θ(n^2)이다.  위에서 Horner 공식을 비교한 코드에선 loop가 n번 반복하므로 공식에 비해 수행시간이 굉장히 길다.





### c. 다음 루프 불변성을 생각하라.

 2-3행에서 while 루프가 각 반복을 시작할 때 다음과 같다.
$$
y=\displaystyle\sum_{k=0}^{n-(i+1)}a_{k+i+1}x^k
$$
항을 갖지 않은 경우의 합은 0으로 해석하라. 증명 과정은 이 장에서 보인 루프 불변성 증명 구조를 잘 따라야 하며, 이 루프 불변성을 이용해 루프가 종료될 때
$$
y=\sum^n_{k=0}a_kx^k
$$
라는 것도 보여라.



답



초기 조건 : i = n이므로 -1번 반복하여 항이 없다. 따라서 0이다. 참

유지 조건 : loop를 돌아 3행을 지나면
$$
y = a_i +xy 이므로 \\
y = a_i + xy = a_i+x\displaystyle\sum_{k=0}^{n-(i+1)}a_{k+i+1}x^k \\
= a_i + \displaystyle\sum_{k=0}^{n-(i+1)}a_{k+i+1}x^{k+1} \\
= a_i + \displaystyle\sum_{k=1}^{n-i}a_{k+i}x^k \\
= a_ix^0 + \displaystyle\sum_{k=1}^{n-i}a_{k+i}x^k \\
=\displaystyle\sum_{k=0}^{n-i}a_{k+i}x^k
$$


종료 조건 : i = 0일때 종료된다. 그렇다면 k=0 부터 n까지 반복하게 되어 원하는 결과를 도출해낼 수 있다.





### d. 끝으로, 주어진 코드가 계수가 a0,a1,...,an인 다항식을 올바르게 계산함을 보여라.

답

위에서 증명함



## 2-4 역위

A[1..n]을 n개의 서로 다른 원소의 배열이라고 하자. i<j이고 A[i] > A[j]라면 (i,j)쌍은 A의 **역위** 한 예가 된다.

### a. 배열<2,3,8,6,1>의 역위 다섯 개를 나열하라.

답

(1,5),(2,5),(3,4)(3,5),(4,5)



### b.집합{1,2,...,n}으로 이루어진 배열이 가장 많은 역위를 갖는 경우는 언제인가? 그리고 이때 역위는 몇 개인가?

답

내림차순 정렬시에 가장 많은 역위를 갖게 된다. 이때 2개를 뽑아 쌍을 만들면 모두 역위이므로 nC2가 되어 n(n-1)/2개이다.





### c. 삽입 정렬의 수행시간과 입력 배열의 역위 개수 사이에는 어떤 관계가 있는가? 이 답을 증명하라.

답

위에서 말했듯 역위는 내림차순 정렬시에 가장 많게 형성된다. 삽입 정렬의 수행시간은 내림차순 정렬시에 최악의 경우로서 n의 제곱을 수행시간으로 갖는다. 따라서 삽입 정렬의 수행시간은 역위의 갯수와 정비례 한다고 할 수 있다.

삽입 정렬때 새로 삽입할 값을 앞으로 이동하면서 비교하고 위치를 바꿔주는 loop가 존재한다. 이 때 두 값이 역위여야만 위치가 바뀐다. 즉 역위의 갯수와 명령문의 실행 횟수는 동일함을 알 수 있다.



### d. 원소가 n개인 임의의 순열에서 역위의 갯수를 최악의 경우 Θ(NlgN)시간에 알아내는 알고리즘을 제시하라(힌트 : 병합 정렬을 변형해보라)



답 

기존 병합 정렬에서 분할한 후에 각각 비교하여 병합하는 과정은 수행시간이 n이였고, lg(N)번 반복하여 NlgN 시간이 걸렸다. 

병합하는 과정은 동일하게 lgN번 반복되야 한다. 각 과정에서 역위의 갯수를 세는 시간을 파악해야 한다. Θ(n)이므로 최악의 경우 역위의 갯수 파악에는 Θ(NlgN)이 소요된다.

병합 정렬에서 분할을 하고 정렬하며 병합하는 과정에서 역위를 발견하면 카운트한 후 위치를 바꾼다. 즉, 기존의 병합 정렬과 명령문 시행 횟수가 동일하므로 병합 정렬과 동일하게 NlgN의 수행시간이 소요된다.
