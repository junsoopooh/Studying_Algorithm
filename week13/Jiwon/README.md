# Week 11

## 문제 리스트

|       |문제번호|난이도|문제제목|혼자 풀었나요?|
|-------|-------|------|-------|-------------|
|7/28(금)|11866|실버5|요세푸스 문제 0|O|
|7/28(금)|3190|골드4|뱀|O|
|7/31(월)|11279|실버2|최대 힙|O|
|7/31(월)|1655|골드2|가운데를 말해요|X|
|7/31(월)|1715|골드4|카드 정렬하기|O|
|8/2(수)|13334|골드2|철로|X|
|8/2(수)|1933|골드1|스카이라인|X|
|8/3(목)|5904|골드5|Moo 게임|O|
|8/3(목)|9935|골드4|문자열 폭발|O|

## 문법, 알고리즘 정리

### 11866 요세푸스 문제 0
- 이렇게 무식하게 푸는게 맞는 건지 모르겠습니다.

### 3190 뱀
- 풀리니까 재밌다. 히히.

### 11279 최대 힙
- heapq에는 최소힙만 있다. 그래서 최대힙으로 넣고 뺄 때는 -를 붙여주어야 함

### ⭐ 1655 가운데를 말해요
- 처음에는 heap에 넣어놓고 가운데 인덱스로 수를 뽑아내면 될 것이라 생각
- 그런데 heap[인덱스]로 접근할 수 없음, 우선순위 큐 성질은 heapq.heappop할 때 발휘되기 때문
- 그래서 heap의 가운데 값을 heappop으로 뽑아낼 수 있도록 조정하는 것이 이 문제의 핵심

### 13334 철로
- 처음에는 분할정복으로 풀어야 한다 생각했음
- 라인 스위핑으로 풀면 한번만 순회해도 답을 얻을 수 있음
- 문제를 읽고 어떤 방식으로 푸는 것이 제일 간단하고 유리할지 생각해 내는 것

### 5904 Moo 게임
- 배열에 저장해나가면서 풀면 메모리 초과 뜸
- N 범위는 (1 ≤ N ≤ 10^9)이기 때문에 분할 정복을 이용해야 함
- 문자열이 왼쪽 부분, 가운데 부분, 오른쪽 부분으로 나뉘므로 이를 통해서 분할 정복

### 9935 문자열 폭발
- while 문 돌리니 시간 초과 뜸, replace()가 오래 걸리는가 봄
- replaceAll이 있나 봤더니 없었음
- 그럼 replaceAll과 같은 역할을 하는 함수가 뭐가 있을까 보다가 split을 생각하게 됨
- 근데 split을 써도 시간 초과 뜸
- 스택을 이용하여 폭발 문자열일 때 그 길이만큼 pop()하도록 구현
- 확인할 때 앞에서부터 확인 못하고, 뒤에서부터 확인할 수 있음